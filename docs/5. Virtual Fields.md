# PHPFUI\ORM Virtual Fields
*__Note__: Referenced namespaces in this document refer to the **PHPFUI\ORM** defaults.*

You can define virtual fields with get and set semantics for any **\App\Record** class. Virtual fields are evaluated before any database field, so you can override the database defaults if needed, or create new functionality.

Every **\App\Record** class has a static $virtualFields array defined. The key of the array is the name of the virtual key.  The value for each virtual field is an array of strings. The first string is the virtual field class name. Subsequent parameters are are passed the the **getValue** and **setValue** methods.

The **VirtualField** class has two properties that will always be defined for use by the derived class:
* $currentRecord is the current record that the virtual field should be based on.
* $fieldName the field name that the VirtualField object was created from.  This is the key of the $virtualFields array in the Record class.

## One To One and Parent Related Record Relationships
If a field is named the same way as a corresponding table and suffixed with the proper ID, **PHPFUI\ORM** will automatically generate a One To One or parent relationship for you.

A child record with an ID field of the parent record automatically has a parent relationship via the build in related record functionality.

In the northwind schema, order_detail records are children of an order record, as they have an order_id key.
```php
$orderDetail = new \App\Record\OrderDetail(27);
$parentOrder = $orderDetail->order;
```
Likewise, the Invoice record has a relationship to its Order record, and from the order, we can get the shipper's company field.
```php
$invoice = new \App\Record\Invoice(7);
echo $invoice->order->shipper->company;
```
## Custom Related Record Relationships
Sometimes you can't name a related record with the name of the table.  For example you might have an Employee table, but yet need to have several references to different employees in the same table. You might have the following fields which are all Employee Ids:
* salesPerson_id
* packedBy_id
* inspectedBy_id

You can make them all return employees with the following virtual field definitions:
```php
class Order extends \Tests\App\Record\Definition\Order
	{
	protected static array $virtualFields = [
		'salesPerson' => [\PHPFUI\ORM\RelatedRecord::class, \App\Record\Employee::class],
		'packedBy' => [\PHPFUI\ORM\RelatedRecord::class, \App\Record\Employee::class],
		'inspectedBy' => [\PHPFUI\ORM\RelatedRecord::class, \App\Record\Employee::class],
	];
	}
```
### Usage
```php
echo 'Sales Person : ' . $order->salesPerson->fullName() . "\n";
echo 'Packed By    : ' . $order->packedBy->initials() . "\n";
echo 'Inspected By : ' . $order->inspectedBy->first_name . "\n";
```

## Custom Virtual Fields
You can write custom classes to create virtual fields on any record. Here we are adding a **gross** virtual to the OrderDetail record.
```php
class Gross extends \PHPFUI\ORM\VirtualField
  {
  public function getValue(array $parameters) : mixed
    {
    return number_format($currentRecord->unit_price * $currentRecord->quantity - $currentRecord->discount, 2);
    }
  }

class OrderDetail extends \Tests\App\Record\Definition\OrderDetail
  {
  protected static array $virtualFields = [
    // define a new virtual field using the above Gross class
    'gross' => [Gross::class],
  ];
  }
```

## Child Records
OrderDetail children for an Order record can be defined as:
```php
class Order extends \Tests\App\Record\Definition\Order
  {
  protected static array $virtualFields = [
    // the OrderDetailChildren will be returned in order_detail_id order. Leave off the third array element to let SQL determine the order if you don't care.
    'OrderDetailChildren' => [\PHPFUI\ORM\Children::class, \Tests\App\Table\OrderDetail::class, 'order_detail_id'],
  ];
  }
```

### Usage
```php
$order = new \App\Record\Order(31);
foreach ($order->OrderDetailChildren as $orderDetail)
  {
  echo "Gross {$orderDetail->gross} for product {$orderDetail->product->product_name}\n";
  }
```

## Many To Many
Many To Many relationships can be easily constructed with a junction table containing the primary keys of the two tables you want with a many to many relationship.

For the Product and Supplier tables, you need to add this:
```php
class Product extends \Tests\Fixtures\Record\Definition\Product
  {
  protected static array $virtualFields = [
    'suppliers' => [\PHPFUI\ORM\ManyToMany::class, \Tests\App\Table\ProductSupplier::class, \Tests\App\Table\Supplier::class],
  ];
  }

class Supplier extends \Tests\Fixtures\Record\Definition\Supplier
  {
  protected static array $virtualFields = [
    'products' => [\PHPFUI\ORM\ManyToMany::class, \Tests\App\Table\ProductSupplier::class, \Tests\App\Table\Product::class],
  ];
  }
```

### Usage
```php
$product = new \App\Record\Product(4);
$suppliers = $product->suppliers;
echo "There are {$suppliers->count()} for product {$product->product_code} - {$product->product_name}:\n";
foreach ($suppliers as $supplier)
  {
  echo $supplier->company . "\n";
  }
```
